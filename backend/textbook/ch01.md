# 주로 쓰는 프레임워크

* Go 1.18 이상 버전
    * 제네렉 프로그램 가능 (이전 버전에 없는 기능)

* GraphQL 라이브러리 서버에에 붙혀서 쓰는 이유
    * 기본 보안기능 구현하지 않아도 되서..
    * GraphQL 서버 + RESTful 서버 구성 가능 -> 서버의 path 구분으로 설정 가능
    * Echo, Express 아닌것에도 붙을수가 있음
    * AWS Lambda 에도 붙혀쓸수 있음 (곧 사용될 기술)

```mermaid
flowchart
    Gin 
    
    subgraph Echo 
        GqlGen[GqlGen: GraphQL Library]
    end
  ```

# 데이터 베이스

1. MySQL (AWS RDB)
    * 대표적인 RDMS
    * 표(리스트형) 데이터 : 데이터를 최대한 중복없이 자세하게 분류한다. => 분류중시 => 불러올때 필요한 정보만 후조합
        * 장점 : 최소한의 데이터, 용량 작음
        * 단점 : 최소한의 데이터 -> 추가할때 큰 비용, 정형화(서로 불러오니까) 되어 자주 바꾸기 어렵다.
    * 특징
        * 트렌젝션 : 제일 중요. 데이터의 무결성(합, 곱)을 반드시 지킬수 있다.
          => 반드시 순서를 지킨다. (장점)
          => 작업시 모든 병렬처리는 무시된다. (단점, 장점) => 요청이 많아질수록 느려진다. (단점) => 서버 능력(속도) 확장의 제한
        * 리스트 형식 : 요구사항이 표로 구성될수 있음
        * 조합 : 리스트형식으로 구성된 표가 서로를 참조(공유)하며 바로바로 적용
2. Mongo (Docker)
    * 대표적인 NoSQL
    * 도큐먼트 (트리, JSON) 데이터 : 가까운(관련된) 데이터를 중복을 허락하며 최대한 가까운곳에 배치. => 관련성을 중시 => 한곳에 모두 모여있다. => 불러와서 후작업
        * 장점 : 정형화 안되어있음. 확장 및 구조변경에서 매우 자유로움
        * 단점 : 용량이큼, 중복을 허락하므로, 데이터의 정확성을 디비단계가 아닌 서비스 구현단계에서 고민해야됨.
    * 특징
        * 병렬처리에 강하다 => 읽기속도가 빠르다, 단점 : 쓰기 속도가 느리다. 또는 정확하지 않다.
        * 트렌젝션이 없다. => 속도가 엄청빠르다. 거의 무조건 병렬처리(순서대로 처리되지 않는다) => 데이터의 정확성은 다소 떨어져 => 시스템 확장에 무제한 (데이터 복제)
3. Redis (Docker)
    * 몽고의 축소판, 대신에 제일 빠르다. (Key-Value)
    * Map, Dictionary
    * 휘발성, (메모리디비), 데이터 변경시 콜백실행 가능

## 도전과제

1. MySQL vs Mongo vs Redis
    * 문자서비스에 어떤 디비를 써야 할까
    * 한개 이상의 디비를 써야 되는 이유
    * 한개 이상의 디비를 쓸때 유의 해야 할 점에 대해서
    * 각 언어별 대표적 라이브러리 도튜먼트 찾아오기